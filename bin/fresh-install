#!/usr/bin/env python3
"""
fresh-install <https://gerrit.wikimedia.org/g/fresh>

This is free and unencumbered software released into the public domain.
"""

import base64
import hashlib
import os
import stat
import sys
import urllib.request


# Inspired by https://gerrit.wikimedia.org/g/mediawiki/tools/scap/+/3.16.0/scap/ansi.py
clr_red = "\x1b[%sm" % (31)
clr_green = "\x1b[%sm" % (32)
clr_yellow = "\x1b[%sm" % (33)
clr_grey = "\x1b[%sm" % (37)
clr_none = "\x1b[%sm" % (39)

bin_candidates = [
    # Preferred location if writable by user (common on macOS)
    '/usr/local/bin',
    # Preferred standard home path
    # https://specifications.freedesktop.org/basedir-spec/
    # https://www.freedesktop.org/software/systemd/man/file-hierarchy.html
    '~/.local/bin',
    # Older convention that is often already in-use, whether by default
    # as on Ubuntu, or from the developer having set PATH this way.
    # https://bugs.launchpad.net/ubuntu/+source/bash/+bug/1588562
    # https://unix.stackexchange.com/a/392710/37512
    '~/bin',
]
bin_dir = None


def install_bin_all():
    """
    Download, verify, and install a shell command.
    """

    # During development this can be a recent commit hash instead of a release tag,
    # to allow full testing prior to release.
    FRESH_VERSION='94b6caedb513dbdea94555e1b905529a7426cc59'
    FRESH_NODE12_SHA256='955162560aca94d829b57043bbbbd30f8002af9a48e8ecd6a3d82e96af36d5c6'
    FRESH_NODE14_SHA256='55b4adcf0f785214605e93fa8904e05e4331b68db6d9dbe6860915bc778b1a96'
    FRESH_NODE16_SHA256='79ed2fc7fc95aff9d4e3835b9c7a5917ebb862650f874292b690f9df2bfdad89'

    # Run get_bin_path first to improve message order
    # e.g. not "creating dir" between two "installing" messages
    get_bin_path()
    install_bin(FRESH_VERSION, 'fresh-node12', FRESH_NODE12_SHA256, 'fresh-node12')
    install_bin(FRESH_VERSION, 'fresh-node14', FRESH_NODE14_SHA256, 'fresh-node14')
    install_bin(FRESH_VERSION, 'fresh-node16', FRESH_NODE16_SHA256, 'fresh-node')

    absent_bin('fresh-node10')

    print('')
    print('%s  Fresh %s is now ready!' % (u'\U0001F331', FRESH_VERSION))


def debug_checksums():
    """
    Make and print new checksums.
    This is for use during release prep, to help update fresh-install.
    """
    make_checksum('fresh-node12')
    make_checksum('fresh-node14')
    make_checksum('fresh-node16')


def warning(message):
    print('%s%s%s' % (clr_yellow, message, clr_none))


def error_exit(message):
    print('fresh-install: %s' % (message), file=sys.stderr)
    print(u'\u274C')
    sys.exit(1)


def install_bin(version_src, cmd_src, cmd_integrity, cmd_dest):
    dest = os.path.join(get_bin_path(), cmd_dest)
    print('%sinstalling %s to %s%s' % (clr_grey, cmd_src, dest, clr_none))

    # Download
    url = 'https://gerrit.wikimedia.org/g/fresh/+/%s/bin/%s?format=TEXT' % (version_src, cmd_src)
    req = urllib.request.Request(url, headers={
        'User-Agent': 'Fresh/%s (Bot) https://gerrit.wikimedia.org/g/fresh' % (version_src)
    })
    if os.getenv('FRESH_INTERNAL_TEST'):
        data = '#!/bin/bash\necho "Fake fresh-node"\n'.encode('utf-8')
        checksum = cmd_integrity
    else:
        try:
            with urllib.request.urlopen(req) as resp:
                data = resp.read().decode('utf-8')
        except urllib.error.HTTPError as e:
            error_exit('HTTP %s at %s' % (e.code, url))

        data = base64.b64decode(data)
        checksum = hashlib.sha256(data).hexdigest()

    # Verify
    if checksum != cmd_integrity:
        error_exit('checksum of %s does not match' % (cmd_src))

    # Store file
    content = str(data, encoding='utf-8')
    with open(dest, 'w') as f:
        f.write(content)

    # Make file executable
    current = os.stat(dest)
    os.chmod(dest, current.st_mode | stat.S_IEXEC)


def get_bin_path():
    global bin_dir

    if bin_dir is None:
        bin_dir = False
        for candidate in bin_candidates:
            candidate = os.path.expanduser(candidate)
            if not candidate in os.get_exec_path():
                continue
            if not os.path.isdir(candidate):
                try:
                    os.makedirs(candidate, exist_ok=True)
                    print('%screating %s%s' % (clr_grey, candidate, clr_none))
                except PermissionError:
                    continue
            if not os.access(candidate, os.W_OK):
                continue
            bin_dir = candidate
            break

    if bin_dir is False:
        using_zsh = os.path.exists(os.path.expanduser('~/.zshrc'))
        shell_configuration = "~/.zshrc" if using_zsh else "~/.bashrc"
        # If we fail, recommend one that doesn't require sudo (e.g. standard home path)
        bin_recommend = '~/.local/bin'
        warning('Tried the following places: %s' % ', '.join(bin_candidates))
        warning('Add "export PATH=$PATH%s%s" in %s and try again.' % (os.pathsep, bin_recommend, shell_configuration))
        error_exit('Could not find writable installation folder')

    return bin_dir


def absent_bin(cmd_dest):
    for candidate in bin_candidates:
        candidate = os.path.expanduser(candidate)
        dest = os.path.join(candidate, cmd_dest)
        try:
            os.remove(dest)
            print('%sremoving %s from %s%s' % (clr_grey, cmd_dest, dest, clr_none))
        except (FileNotFoundError, OSError) as e:
            # Ignore if already gone
            # Ignore if no permission to remove
            pass


def make_checksum(cmd_src):
    with open('./bin/%s' % cmd_src, 'r') as f:
        checksum = hashlib.sha256(f.read().encode('utf-8')).hexdigest()

    print('New checksum for %s: %s' % (cmd_src, checksum))


debug = (len(sys.argv) == 2 and sys.argv[1] == '--debug')
if debug:
    debug_checksums()
else:
    install_bin_all()
